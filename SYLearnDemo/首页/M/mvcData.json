{
    "code":200,
    "msg":"success",
    "data":{
        "content":"MVC最早存在于桌面程序中的, M是指业务数据, V是指用户界面, C则是控制器. 在具体的业务场景中,  C作为M和V之间的连接, 负责获取输入的业务数据, 然后将处理后的数据输出到界面上做相应展示, 另外, 在数据有所更新时, C还需要及时提交相应更新到界面展示. 在上述过程中, 因为M和V之间是完全隔离的, 所以在业务场景切换时, 通常只需要替换相应的C, 复用已有的M和V便可快速搭建新的业务场景. MVC因其复用性, 大大提高了开发效率, 现已被广泛应用在各端开发中.\n\n在刚刚学习iOS的时候，一直以为C层就一定是viewcontroller，然后也不知道隔离M与V，所以每次写的时候，都是直接在view里面setModel，然后在viewcontroller中赋值model给view，例如：\n//VC中\ncell.model = model\n//cell中\n- (void)setModel:(*model)model\n正确的MVC写法：\nC层提供构造方法和必要的获取数据的接口，内部进行初始化。M层进行接口数据的处理，V层提供set方法供外部调用。\n具体写法请参考简书链接https://www.jianshu.com/p/eedbc820d40a\n我也是从这里开始学习MVC的，可能还不是很熟悉，但是孰能生巧。\n总结：\n平时的写法缺点：代码复用性差并且臃肿，所有逻辑布局都放在了viewcontroller中，导致拓展性变差。\n虽然MVC模式解决了以上的问题，但是还是有一些缺点：\n1.过度的注重隔离: 这个其实MV(x)系列都有这缺点, 为了实现V层的完全隔离, V对外只暴露Set方法, 一般情况下没什么问题, 但是当需要设置的属性很多时, 大量重复的Set方法写起来还是很累人的.\n2.业务逻辑和业务展示强耦合: 可以看到, 有些业务逻辑(页面跳转/点赞/分享...)是直接散落在V层的, 这意味着我们在测试这些逻辑时, 必须首先生成对应的V, 然后才能进行测试. 显然, 这是不合理的. 因为业务逻辑最终改变的是数据M, 我们的关注点应该在M上, 而不是展示M的V."
    }
}
